```cpp
#include <bits/stdc++.h>

using namespace std;
const int maxn = 100;
const int maxm = 10000;
const int INF = 0x3f3f3f3f;

int n,m,tot;
int l[maxn],h[maxn],cur[maxn];

struct edge{
  int to,c,next;
  edge(int x = 0, int y = 0, int z = 0) : to(x),c(y),next(z) {}
}es[maxm*2];

void add_edge(int u, int v, int c)
{
  es[tot] = edge(v,c,h[u]);
  h[u] = tot++;
  es[tot] = edge(u,0,h[v]);
  h[v] = tot++;
}

bool bfs(int s, int t)
{
  memset(l,0,sizeof(l));
  l[s] = 1;
  queue <int> q;
  q.push(s);
  while(!q.empty())
  {
    int u = q.front();
    q.pop();
    if(u == t) return true;
    for(int i = h[u]; i != -1; i = es[i].next)
    {
      int v = es[i].to;
      if(!l[v] && es[i].c)
      {
        l[v] = l[u] + 1;
        q.push(v);
      }
    }
  }
  return false;
}

int dfs(int x, int t, int mf)
{
  if(x == t) return mf;
  int ret = 0;
  for(int &i = cur[x]; i != -1; i = es[i].next)
  {
    int v = es[i].to;
    if(es[i].c && l[v] == l[x] + 1)
    {
      int f = dfs(v,t,min(es[i].c,mf-ret));
      es[i].c -= f;
      es[i^1].c += f;
      ret += f;
      if(ret == mf) return ret;
    }
  }
  return ret;
}

int dinic(int s, int t)
{
  int ans = 0;
  while(bfs(s,t))
  {
    for(int i = 0; i <= t; i++) cur[i] = h[i];
    ans += dfs(s,t,INF);
  }
  return ans;
}

int in[maxn];

int fun(int s, int t, string str)
{
  if(str[0] == '+') return s;
  if(str[0] == '-') return t;
  int res = 0;
  for(int i = 0; i < str.size(); i++)
  {
    res *= 10;
    res += str[i]-'0';
  }
  return res;
}
int main()
{
  //freopen("i.txt","r",stdin);
  //freopen("out.txt","w",stdout);
  while(~scanf("%d%d",&n,&m))
  {
    if(n == 0 && m == 0) continue;
    tot = 0;
    memset(h,-1,sizeof(h));
    memset(in,0,sizeof(in));
    int s = n+1, t = n+2, ss = 0, tt = t+1;
    for(int i = 0; i < m; i++)
    {
      string s1,s2;
      int u,v,p;
      cin >> s1 >> s2;
      scanf("%d",&p);
      u = fun(s,t,s1);
      v = fun(s,t,s2);
      in[u] -= p;
      in[v] += p;
      add_edge(u,v,INF);
    }
    int res = 0;
    for(int i = 1; i <= t; i++)
    {
      if(in[i] > 0)
      {
        res += in[i];
        add_edge(ss,i,in[i]);
      }
      if(in[i] < 0)  add_edge(i,tt,-in[i]);
    }
    int ans = dinic(ss,tt);
    add_edge(t,s,INF);
    ans += dinic(ss,tt);
    if(res == ans)  printf("%d\n",es[h[t]^1].c);
    else printf("impossible\n");
  }
  return 0;
}
```
